#!/pubhome/qcxia02/miniconda3/envs/basic/bin/python3.9
import os
import sys
import argparse
from pathlib import Path, PosixPath

from rdkit import Chem
from rdkit.Chem import Draw

sys.path.append("/pubhome/qcxia02/git-repo/TorsionNet/RDK_torsion/rdkit_Pfrag/utils")
from TFG_TEU import TorsionFragmentGenerator_TEU


if True:
    """
    Usage: python rdkit_Pfrag.py --mol2 mol2file.mol2 --outpath outpath --imgpath imgpath --rmsd 0.1 --numConfs 20 &> log
    """
    parser = argparse.ArgumentParser("RDKit Torsion Fragment Generator")
    input_group = parser.add_mutually_exclusive_group(required=True)
    input_group.add_argument("--sdf", type=str, help="path for sdf file with single M")
    input_group.add_argument("--mol2", type=str, help="path for mol2 file with single M")
    parser.add_argument("--outpath",type=PosixPath, help="path for output .sdf mols")
    parser.add_argument("--imgpath",type=PosixPath, help="path for output imgs")
    parser.add_argument("--rmsd",type=float, help="RMSD threshold for ETKDG conformation sampling diversity ")
    parser.add_argument("--numConfs",type=int, help="Set max number of conformers generated by ETKDG sampling")
    parser.add_argument("--unicon", action="store_true",default=False,help="whether to implement unicon to change the protonation state")

    args = parser.parse_args()

    # mol = Chem.MolFromSmiles("COc3ccc(C)c(C(C)NC(=O)Nc2nc(c1ccncc1)cs2)c3C")
    # mol = Chem.SDMolSupplier(args.sdf, removeHs = False)[0]
    mol2file = args.mol2
    sdffile = args.sdf
    outpath = args.outpath
    imgpath = args.imgpath
    rmsd = args.rmsd
    numConfs = args.numConfs

    for path in [outpath, imgpath]:
        if not path.exists():
            os.system(f"mkdir -p {str(path)}")

    if args.sdf:
        if args.unicon: # implement unicon to predict protonation state
            uniconpath = outpath / "uniconed"
            os.system(f"mkdir {uniconpath}")
            newsdffile = uniconpath / (Path(sdffile).name + ".uniconed" + ".sdf")
            os.system(f"unicon -i {sdffile} -t topscoring  -p topscoring -m 1  --hydrogens -o {newsdffile}")

            mol = Chem.SDMolSupplier(newsdffile, sanitize = False, removeHs = False)[0] # readfile
            molname = Path(sdffile).name[:-4]
        else: # without unicon, directly read
            mol = Chem.SDMolSupplier(sdffile, sanitize = False, removeHs = False)[0] # readfile
            molname = Path(sdffile).name[:-4]

    if args.mol2:
        if args.unicon: # implement unicon to predict protonation state
            uniconpath = outpath / "uniconed"
            os.system(f"mkdir {uniconpath}")
            newmol2file = str(uniconpath / (Path(mol2file).name + ".uniconed" + ".mol2"))
            os.system(f"unicon -i {mol2file} -t topscoring  -p topscoring -m 1  --hydrogens -o {newmol2file}")

            mol = Chem.MolFromMol2File(newmol2file, sanitize = False, removeHs = False) # readfile
            molname = Path(mol2file).name[:-5]
        else:
            # mol = Chem.MolFromMol2File(mol2file, sanitize = False, removeHs = False) # readfile
            mol = Chem.MolFromMol2File(mol2file, removeHs = False) # readfile, sanitize=True
            molname = Path(mol2file).name[:-5]

    print(f">>>>>> Dealing with {molname} <<<<<<")

    ### OUTPUT .sdf molecules will be saved in outpath dir at current working directory
    # TFG_TL.py no canonicalize step
    TF = TorsionFragmentGenerator_TEU(mol, outpath=outpath, name=molname, rmsd=rmsd, numConfs=numConfs) # This name is the prefix for output SDF mol


    new_mols = TF.mols
    old_quartets = TF.old_quartets
    new_quartets = TF.new_quartets
    out_names = TF.outnames

    print(f">>> Total {len(new_mols)} torsion fragments")

    for i, new_mol in enumerate(new_mols):
        quartet = new_mol.GetProp("TORSION_ATOMS_FRAGMENT").split(" ")
        quartet = [int(idx) for idx in quartet]
        print(f">>>>>> New quartet atoms for {i}:")
        print(quartet)
    
    if new_quartets: # only when with torsion, can output
        img = Draw.MolsToGridImage(
        [ Chem.MolFromSmiles(Chem.MolToSmiles(new_mol)) for new_mol in new_mols],
        molsPerRow=5,
        subImgSize=(350,350),
        legends = out_names
    )
        img.save(str(imgpath / (molname + ".png")))

    print(f">>>>>> Finished with {molname} <<<<<<")
    print()
